/*
 * ================================================================================================
 *  WARNING: This file is automatically generated by cbindgen. Manual edits are likely to be lost.
 * ================================================================================================
 */

#ifndef LAKERS_C_H
#define LAKERS_C_H

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include "lakers_shared.h"
#include "lakers_ead_authz.h"

/**
 * Note that while the Rust version supports optional value to indicate an empty value,
 * in the C version we use an empty buffer for that case.
 */
typedef struct EADItemC {
  uint8_t label;
  bool is_critical;
  EdhocMessageBuffer value;
} EADItemC;

/**
 * structs compatible with the C FFI
 */
typedef struct EdhocInitiatorC {
  InitiatorStart state;
} EdhocInitiatorC;

typedef struct EdhocInitiatorWaitM2C {
  WaitM2 state;
} EdhocInitiatorWaitM2C;

typedef struct ProcessingM2C {
  BytesMac2 mac_2;
  BytesHashLen prk_2e;
  BytesHashLen th_2;
  BytesP256ElemLen x;
  BytesP256ElemLen g_y;
  EdhocMessageBuffer plaintext_2;
  uint8_t c_r;
  struct EADItemC *ead_2;
} ProcessingM2C;

typedef struct EdhocInitiatorProcessingM2C {
  struct ProcessingM2C state;
} EdhocInitiatorProcessingM2C;

typedef struct EdhocInitiatorProcessedM2C {
  ProcessedM2 state;
  CredentialRPK cred_i;
} EdhocInitiatorProcessedM2C;

typedef struct EdhocInitiatorDoneC {
  Completed state;
} EdhocInitiatorDoneC;

int8_t credential_rpk_new(const uint8_t *value, uintptr_t value_len, CredentialRPK *cred);

void p256_generate_key_pair_from_c(uint8_t *out_private_key, uint8_t *out_public_key);

ZeroTouchDevice authz_device_new(const uint8_t *id_u,
                                 uintptr_t id_u_len,
                                 const BytesP256ElemLen *g_w,
                                 const uint8_t *loc_w,
                                 uintptr_t loc_w_len);

int8_t authz_device_prepare_ead_1(const ZeroTouchDevice *device_c,
                                  const BytesP256ElemLen *secret,
                                  uint8_t ss,
                                  ZeroTouchDeviceWaitEAD2 *device_c_out,
                                  struct EADItemC *ead_1_c_out);

int8_t authz_device_process_ead_2(ZeroTouchDeviceWaitEAD2 *device,
                                  struct EADItemC *ead_2_c,
                                  CredentialRPK cred_v,
                                  ZeroTouchDeviceDone *device_c_out);

struct EdhocInitiatorC initiator_new(void);

int8_t initiator_prepare_message_1(struct EdhocInitiatorC *initiator_c,
                                   uint8_t *c_i,
                                   struct EADItemC *ead_1_c,
                                   struct EdhocInitiatorWaitM2C *initiator_c_out,
                                   EdhocMessageBuffer *message_1);

int8_t initiator_parse_message_2(struct EdhocInitiatorWaitM2C *initiator_c,
                                 const EdhocMessageBuffer *message_2,
                                 CredentialRPK expected_cred_r,
                                 struct EdhocInitiatorProcessingM2C *initiator_c_out,
                                 uint8_t *c_r_out,
                                 CredentialRPK *valid_cred_r_out,
                                 struct EADItemC *ead_2_c_out);

int8_t initiator_verify_message_2(struct EdhocInitiatorProcessingM2C *initiator_c,
                                  const BytesP256ElemLen *i,
                                  CredentialRPK cred_i,
                                  CredentialRPK valid_cred_r,
                                  struct EdhocInitiatorProcessedM2C *initiator_c_out);

int8_t initiator_prepare_message_3(struct EdhocInitiatorProcessedM2C *initiator_c,
                                   CredentialTransfer cred_transfer,
                                   struct EADItemC *ead_3_c,
                                   struct EdhocInitiatorDoneC *initiator_c_out,
                                   EdhocMessageBuffer *message_3,
                                   uint8_t (*prk_out_c)[SHA256_DIGEST_LEN]);

int8_t initiator_compute_ephemeral_secret(const struct EdhocInitiatorC *initiator_c,
                                          const BytesP256ElemLen *g_a,
                                          BytesP256ElemLen *secret_c_out);

#endif /* LAKERS_C_H */
